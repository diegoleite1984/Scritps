import fitz  # PyMuPDF
import re
import pandas as pd
from pathlib import Path
from collections import defaultdict
import os

# --- Configura√ß√µes ---
pasta_pdfs = r"Z:\DESSS\Apoio Tecnico\MODELOS 2025\APOSENTADORIA\Deferida"
nome_arquivo_saida = "2020.xlsx"

# Verificar se a pasta existe
pasta_path = Path(pasta_pdfs)
if not pasta_path.exists():
    print(f"Erro: A pasta '{pasta_pdfs}' n√£o existe.")
    exit()

# Listar todos os PDFs na pasta
pdf_files = list(pasta_path.rglob("*.pdf"))
if not pdf_files:
    print("Nenhum PDF encontrado na pasta.")
    exit()

print(f"Encontrados {len(pdf_files)} arquivos PDF para processar.")

# Estrutura para armazenar os dados agrupados por pessoa
dados_agrupados = defaultdict(lambda: {"CID": set(), "Cargo": "", "√ìrg√£o": "", "Arquivos": []})

# Processar cada PDF
for pdf_file in pdf_files:
    print(f"Processando: {pdf_file.name}")

    try:
        with fitz.open(pdf_file) as doc:
            texto_extraido = ""
            for page in doc:
                texto_extraido += page.get_text()

        # --- Extra√ß√£o com m√∫ltiplos padr√µes ---
        nomes = re.findall(r"Nome:\s*([^\n\r]+)", texto_extraido)
        cpfs = re.findall(r"\b\d{3}\.\d{3}\.\d{3}-\d{2}\b", texto_extraido)
        cids = re.findall(r"CID-10:\s*([A-Z0-9\.]+)", texto_extraido)

        # Padr√µes para Cargo (Cargo ou Cargo/Fun√ß√£o)
        cargos = re.findall(r"Cargo(?:/Fun√ß√£o)?:\s*([^\n\r]+)", texto_extraido)

        # Padr√µes para √ìrg√£o (√ìrg√£o, √ìrg√£o de Lota√ß√£o ou Lota√ß√£o)
        orgaos = re.findall(r"(?:√ì[rR][gG][√£aA][oO](?:\s+de\s+Lota√ß√£o)?|Lota[c√ß][a√£]o):\s*([^\n\r]+)", texto_extraido)

        # Se n√£o encontrar com os padr√µes principais, tenta alternativas espec√≠ficas
        if not cargos:
            cargos = re.findall(r"Cargo/Fun√ß√£o:\s*([^\n\r]+)", texto_extraido)
        if not orgaos:
            orgaos = re.findall(r"√ìrg√£o de Lota√ß√£o:\s*([^\n\r]+)", texto_extraido)
        if not orgaos:
            orgaos = re.findall(r"Lota[c√ß][a√£]o:\s*([^\n\r]+)", texto_extraido)

        # Garantir que todas as listas tenham o mesmo tamanho
        max_len = max(len(nomes), len(cpfs), len(cargos), len(orgaos), 1)

        # Preencher listas menores com valores vazios
        nomes += [""] * (max_len - len(nomes))
        cpfs += [""] * (max_len - len(cpfs))
        cargos += [""] * (max_len - len(cargos))
        orgaos += [""] * (max_len - len(orgaos))

        # Agrupar dados
        for i in range(max_len):
            chave = (nomes[i].strip(), cpfs[i].strip())
            if chave[0]:  # S√≥ adiciona se tiver nome
                dados_agrupados[chave]["CID"].update(cids)
                if cargos[i].strip():
                    dados_agrupados[chave]["Cargo"] = cargos[i].strip()
                if orgaos[i].strip():
                    dados_agrupados[chave]["√ìrg√£o"] = orgaos[i].strip()
                dados_agrupados[chave]["Arquivos"].append(pdf_file.name)

    except Exception as e:
        print(f"Erro ao processar {pdf_file.name}: {e}")

# Criar DataFrame final
linhas = []
max_cids = 0

for (nome, cpf), info in dados_agrupados.items():
    cids_lista = sorted(info["CID"])
    max_cids = max(max_cids, len(cids_lista))

    linha = {
        "Nome": nome,
        "CPF": cpf,
        "Cargo": info["Cargo"],
        "√ìrg√£o": info["√ìrg√£o"],
        "Arquivos": "; ".join(info["Arquivos"]),
        "Total_CIDs": len(cids_lista)
    }

    # Adicionar CIDs em colunas separadas
    for idx, cid in enumerate(cids_lista, start=1):
        linha[f"CID_{idx}"] = cid

    linhas.append(linha)

# Criar DataFrame
df = pd.DataFrame(linhas)

# Garantir que todas as colunas CID existam e estejam na ordem correta
colunas_cid = []
for i in range(1, max_cids + 1):
    coluna = f"CID_{i}"
    colunas_cid.append(coluna)
    if coluna not in df.columns:
        df[coluna] = ""

# Reordenar colunas
colunas_ordenadas = ["Nome", "CPF", "Cargo", "√ìrg√£o", "Total_CIDs", "Arquivos"] + colunas_cid
df = df[colunas_ordenadas]

# Mostrar preview dos dados no console
print(f"\nPreview dos dados no DataFrame:")
print(df.head().to_string(index=False))
print(f"\nShape do DataFrame: {df.shape}")

# Caminho completo do arquivo de sa√≠da
excel_path = pasta_path / nome_arquivo_saida

# Salvar Excel com configura√ß√µes espec√≠ficas
try:
    # Remover arquivo existente se houver
    if excel_path.exists():
        os.remove(excel_path)
        print("Arquivo existente removido.")

    # Salvar com engine openpyxl
    with pd.ExcelWriter(excel_path, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name='Resultados')

        # Ajustar largura das colunas automaticamente
        worksheet = writer.sheets['Resultados']
        for idx, col in enumerate(df.columns):
            max_length = max(df[col].astype(str).map(len).max(), len(col)) + 2
            worksheet.column_dimensions[chr(65 + idx)].width = min(max_length, 50)

    print(f"\n‚úÖ Extra√ß√£o conclu√≠da com sucesso!")
    print(f"üìä Total de registros: {len(df)}")
    print(f"üíæ Arquivo Excel salvo em: {excel_path}")

    # Verificar se o arquivo foi criado corretamente
    if excel_path.exists():
        print(f"üìÅ Tamanho do arquivo: {excel_path.stat().st_size} bytes")

        # Tentar ler o arquivo salvo para verificar
        try:
            df_verificacao = pd.read_excel(excel_path)
            print(f"‚úÖ Arquivo lido com sucesso - {len(df_verificacao)} registros verificados")
            print(f"üìã Colunas no arquivo salvo: {list(df_verificacao.columns)}")
        except Exception as e:
            print(f"‚ùå Erro ao verificar arquivo salvo: {e}")
    else:
        print("‚ùå Erro: Arquivo Excel n√£o foi criado.")

except Exception as e:
    print(f"‚ùå Erro ao salvar Excel: {e}")
    print("Tentando salvar com m√©todo alternativo...")

    # M√©todo alternativo
    try:
        df.to_excel(excel_path, index=False)
        print("‚úÖ Salvo com m√©todo alternativo.")
    except Exception as e2:
        print(f"‚ùå Erro no m√©todo alternativo: {e2}")

# Mostrar estat√≠sticas finais
print(f"\nüìà Estat√≠sticas finais:")
print(f"- Pessoas √∫nicas encontradas: {len(df)}")
print(f"- M√°ximo de CIDs por pessoa: {max_cids}")
print(f"- Total de PDFs processados: {len(pdf_files)}")

# Mostrar exemplos dos dados extra√≠dos
print(f"\nüîç Exemplos de dados extra√≠dos:")
if len(df) > 0:
    print(f"Primeira pessoa: {df.iloc[0]['Nome']}")
    print(f"Cargo: {df.iloc[0]['Cargo']}")
    print(f"√ìrg√£o: {df.iloc[0]['√ìrg√£o']}")
    print(f"CIDs: {[df.iloc[0][col] for col in df.columns if col.startswith('CID_') and df.iloc[0][col]]}")

df.to_excel('2025.xlsx', index=False)
